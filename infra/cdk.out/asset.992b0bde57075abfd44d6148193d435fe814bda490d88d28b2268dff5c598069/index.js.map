{
  "version": 3,
  "sources": ["../../../aws/lambda/scanner/index.ts"],
  "sourcesContent": ["import { APIGatewayProxyHandler } from 'aws-lambda';\r\nimport { BedrockRuntimeClient, InvokeModelCommand } from \"@aws-sdk/client-bedrock-runtime\";\r\n\r\n// Initialize Bedrock Client (Region is important, us-east-1 usually has Claude)\r\nconst client = new BedrockRuntimeClient({ region: \"us-east-1\" });\r\nconst MODEL_ID = \"anthropic.claude-3-sonnet-20240229-v1:0\";\r\n\r\nexport const handler: APIGatewayProxyHandler = async (event) => {\r\n    console.log(\"Received scan request:\", event.body);\r\n\r\n    try {\r\n        if (!event.body) {\r\n            return { statusCode: 400, body: JSON.stringify({ error: \"No body provided\" }) };\r\n        }\r\n\r\n        const { owner, repo, token } = JSON.parse(event.body);\r\n\r\n        if (!owner || !repo || !token) {\r\n            return { statusCode: 400, body: JSON.stringify({ error: \"Missing required fields: owner, repo, token\" }) };\r\n        }\r\n\r\n        // 1. Fetch File Content from GitHub (Same logic as original service)\r\n        const files = await fetchRepoFiles(token, owner, repo);\r\n        const codeFiles = files.filter((f: any) => /\\.(js|ts|tsx|jsx|py|go|rs|java|sol)$/.test(f.path));\r\n\r\n        // Use a concurrency limit or just Promise.all depending on file count (limit to 10 for now)\r\n        const fileContents = await Promise.all(\r\n            codeFiles.slice(0, 10).map((f: any) => fetchFileContent(token, owner, repo, f.path))\r\n        );\r\n\r\n        // 2. Construct Prompt\r\n        const prompt = constructPrompt(fileContents);\r\n\r\n        // 3. Invoke Amazon Bedrock (Claude 3.5 Sonnet)\r\n        const payload = {\r\n            anthropic_version: \"bedrock-2023-05-31\",\r\n            max_tokens: 4000,\r\n            messages: [\r\n                {\r\n                    role: \"user\",\r\n                    content: [{ type: \"text\", text: prompt }],\r\n                },\r\n            ],\r\n        };\r\n\r\n        const command = new InvokeModelCommand({\r\n            contentType: \"application/json\",\r\n            body: JSON.stringify(payload),\r\n            modelId: MODEL_ID,\r\n        });\r\n\r\n        console.log(\"Invoking Bedrock model:\", MODEL_ID);\r\n        const response = await client.send(command);\r\n\r\n        // Parse Bedrock Response\r\n        const responseBody = JSON.parse(new TextDecoder().decode(response.body));\r\n        const aiText = responseBody.content[0].text;\r\n\r\n        const scanResult = parseResponse(aiText);\r\n\r\n        return {\r\n            statusCode: 200,\r\n            body: JSON.stringify(scanResult),\r\n            headers: { \"Content-Type\": \"application/json\" }\r\n        };\r\n\r\n    } catch (error: any) {\r\n        console.error(\"Lambda Scan Failed:\", error);\r\n        return {\r\n            statusCode: 500,\r\n            body: JSON.stringify({ error: error.message || \"Internal Server Error\" })\r\n        };\r\n    }\r\n};\r\n\r\n// --- Helper Functions (Ported from ScannerService) ---\r\n\r\nasync function fetchRepoFiles(token: string, owner: string, repo: string, path = \"\"): Promise<any[]> {\r\n    const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {\r\n        headers: { Authorization: `Bearer ${token}` }\r\n    });\r\n    if (!res.ok) throw new Error(`GitHub Fetch Failed: ${res.statusText}`);\r\n\r\n    const data = await res.json();\r\n    let files: any[] = [];\r\n    if (Array.isArray(data)) {\r\n        for (const item of data) {\r\n            if (item.type === \"file\") files.push(item);\r\n        }\r\n    }\r\n    return files;\r\n}\r\n\r\nasync function fetchFileContent(token: string, owner: string, repo: string, path: string): Promise<{ path: string, content: string }> {\r\n    const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {\r\n        headers: { Authorization: `Bearer ${token}` }\r\n    });\r\n    const data = await res.json();\r\n    const content = Buffer.from(data.content, \"base64\").toString(\"utf-8\");\r\n    return { path, content };\r\n}\r\n\r\nfunction constructPrompt(files: { path: string, content: string }[]): string {\r\n    let codeContext = \"\";\r\n    for (const file of files) {\r\n        codeContext += `\\n--- FILE: ${file.path} ---\\n${file.content}\\n`;\r\n    }\r\n\r\n    return `\r\n    You are an expert Cyber Security Analyst. Analyze the following code for security vulnerabilities.\r\n    \r\n    Code Context:\r\n    ${codeContext}\r\n\r\n    Output Format: JSON object with \"findings\" (array) and \"summary\" (string).\r\n    Each finding should have:\r\n    - type: string (e.g., \"SQL Injection\", \"XSS\", \"Dependency Vulnerability\")\r\n    - name: string (short title, max 50 characters)\r\n    - severity: \"Critical\" | \"High\" | \"Medium\" | \"Low\"\r\n    - location: string (file path)\r\n    - description: string (ONE LINE ONLY, max 80 characters, concise explanation)\r\n    - fix: string (brief fix suggestion, max 150 characters)\r\n    - fixTime: string (estimated time, e.g., \"30 min\", \"1 hr\", \"2 hr\")\r\n    - detailedAnalysis: string (optional, detailed explanation)\r\n    - subIssues: array (optional, for dependencies) with {id, cve, severity, package, version, analysis}\r\n\r\n    IMPORTANT: \r\n    - Keep descriptions very short and concise (one line, max 80 characters).\r\n    - For dependency vulnerabilities (Next.js, React), include subIssues with CVE info.\r\n    - Return ONLY valid JSON.\r\n    `;\r\n}\r\n\r\nfunction parseResponse(text: string): any {\r\n    try {\r\n        const cleanText = text.replace(/```json/g, \"\").replace(/```/g, \"\").trim();\r\n        return JSON.parse(cleanText);\r\n    } catch (e) {\r\n        console.error(\"Parse error:\", e);\r\n        return { findings: [], summary: \"Failed to parse analysis results.\" };\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["scanner_exports", "__export", "handler", "__toCommonJS", "import_client_bedrock_runtime", "client", "MODEL_ID", "event", "owner", "repo", "token", "codeFiles", "fetchRepoFiles", "f", "fileContents", "fetchFileContent", "payload", "constructPrompt", "command", "response", "aiText", "scanResult", "parseResponse", "error", "path", "res", "data", "files", "item", "content", "codeContext", "file", "text", "cleanText"]
}
