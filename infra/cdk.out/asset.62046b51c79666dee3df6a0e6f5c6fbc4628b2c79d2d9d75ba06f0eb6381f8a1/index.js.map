{
  "version": 3,
  "sources": ["../../../aws/lambda/scanner/index.ts"],
  "sourcesContent": ["import { APIGatewayProxyHandler } from 'aws-lambda';\r\n\r\nexport const handler: APIGatewayProxyHandler = async (event) => {\r\n    console.log(\"Received scan request\");\r\n\r\n    try {\r\n        if (!event.body) {\r\n            return { statusCode: 400, body: JSON.stringify({ error: \"No body provided\" }) };\r\n        }\r\n\r\n        const { owner, repo, token, apiKey } = JSON.parse(event.body);\r\n\r\n        if (!owner || !repo || !token || !apiKey) {\r\n            return { statusCode: 400, body: JSON.stringify({ error: \"Missing required fields: owner, repo, token, apiKey (for Gemini)\" }) };\r\n        }\r\n\r\n        // 1. Fetch File Content from GitHub\r\n        const files = await fetchRepoFiles(token, owner, repo);\r\n        const codeFiles = files.filter((f: any) => /\\.(js|ts|tsx|jsx|py|go|rs|java|sol)$/.test(f.path));\r\n\r\n        console.log(`Found ${codeFiles.length} code files. Fetching content...`);\r\n\r\n        // Limit to 10 files\r\n        const fileContents = await Promise.all(\r\n            codeFiles.slice(0, 10).map((f: any) => fetchFileContent(token, owner, repo, f.path))\r\n        );\r\n\r\n        // 2. Construct Prompt\r\n        const prompt = constructPrompt(fileContents);\r\n\r\n        // 3. Invoke Google Gemini (REST API) with Retry Logic\r\n        console.log(\"Invoking Google Gemini with deterministic settings...\");\r\n\r\n        const MAX_RETRIES = 3;\r\n        const INITIAL_DELAY = 2000; // 2 seconds\r\n        let lastError: any = null;\r\n        let response: any = null;\r\n\r\n        for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {\r\n            try {\r\n                response = await fetch(\r\n                    `https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent?key=${apiKey}`,\r\n                    {\r\n                        method: 'POST',\r\n                        headers: { 'Content-Type': 'application/json' },\r\n                        body: JSON.stringify({\r\n                            contents: [{\r\n                                parts: [{ text: prompt }]\r\n                            }],\r\n                            generationConfig: {\r\n                                temperature: 0,           // Maximum determinism (no randomness)\r\n                                topK: 1,                  // Only consider top 1 token\r\n                                topP: 0.1,                // Minimal nucleus sampling\r\n                                candidateCount: 1,        // Single response\r\n                                maxOutputTokens: 8192     // Sufficient for detailed findings\r\n                            }\r\n                        })\r\n                    }\r\n                );\r\n\r\n                // If successful or non-retryable error, break\r\n                if (response.ok) {\r\n                    console.log(`\u2705 Gemini API call succeeded on attempt ${attempt + 1}`);\r\n                    break;\r\n                }\r\n\r\n                // Check if error is retryable (503, 429, 500)\r\n                const errorData = await response.clone().json().catch(() => ({}));\r\n                const isRetryable = response.status === 503 || response.status === 429 || response.status === 500;\r\n\r\n                if (!isRetryable || attempt === MAX_RETRIES) {\r\n                    // Non-retryable error or max retries reached\r\n                    break;\r\n                }\r\n\r\n                // Calculate exponential backoff delay\r\n                const delay = INITIAL_DELAY * Math.pow(2, attempt);\r\n                console.warn(`\u26A0\uFE0F Gemini API returned ${response.status}. Retrying in ${delay}ms... (Attempt ${attempt + 1}/${MAX_RETRIES})`);\r\n\r\n                await new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n            } catch (error) {\r\n                lastError = error;\r\n                console.error(`\u274C Gemini API call failed on attempt ${attempt + 1}:`, error);\r\n\r\n                if (attempt === MAX_RETRIES) {\r\n                    throw error;\r\n                }\r\n\r\n                const delay = INITIAL_DELAY * Math.pow(2, attempt);\r\n                console.warn(`Retrying in ${delay}ms...`);\r\n                await new Promise(resolve => setTimeout(resolve, delay));\r\n            }\r\n        }\r\n\r\n        if (!response || !response.ok) {\r\n            const errorText = await response.text();\r\n            console.error(\"Gemini API error:\", errorText);\r\n            throw new Error(`Gemini API error: ${response.status} - ${errorText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        const aiText = data.candidates[0].content.parts[0].text;\r\n\r\n        const scanResult = parseResponse(aiText);\r\n\r\n        return {\r\n            statusCode: 200,\r\n            body: JSON.stringify(scanResult),\r\n            headers: { \"Content-Type\": \"application/json\" }\r\n        };\r\n\r\n    } catch (error: any) {\r\n        console.error(\"Lambda Scan Failed:\", error);\r\n        return {\r\n            statusCode: 500,\r\n            body: JSON.stringify({ error: error.message || \"Internal Server Error\" })\r\n        };\r\n    }\r\n};\r\n\r\n// --- Helper Functions ---\r\n\r\nasync function fetchRepoFiles(token: string, owner: string, repo: string, path = \"\"): Promise<any[]> {\r\n    console.log(`Fetching files from: https://api.github.com/repos/${owner}/${repo}/contents/${path}`);\r\n    const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {\r\n        headers: {\r\n            Authorization: `Bearer ${token}`,\r\n            \"User-Agent\": \"Oreva-Scanner-Lambda\",\r\n            \"Accept\": \"application/vnd.github.v3+json\"\r\n        }\r\n    });\r\n    if (!res.ok) {\r\n        const errorBody = await res.text();\r\n        console.error(`GitHub Fetch Failed (${res.status}):`, errorBody);\r\n        throw new Error(`GitHub Fetch Failed: ${res.statusText} (${res.status}) - ${errorBody}`);\r\n    }\r\n\r\n    const data = await res.json();\r\n    let files: any[] = [];\r\n    if (Array.isArray(data)) {\r\n        for (const item of data) {\r\n            if (item.type === \"file\") files.push(item);\r\n        }\r\n    }\r\n    return files;\r\n}\r\n\r\nasync function fetchFileContent(token: string, owner: string, repo: string, path: string): Promise<{ path: string, content: string }> {\r\n    const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {\r\n        headers: {\r\n            Authorization: `Bearer ${token}`,\r\n            \"User-Agent\": \"Oreva-Scanner-Lambda\",\r\n            \"Accept\": \"application/vnd.github.v3+json\"\r\n        }\r\n    });\r\n\r\n    if (!res.ok) {\r\n        const errorBody = await res.text();\r\n        console.error(`GitHub Content Fetch Failed (${res.status}):`, errorBody);\r\n        throw new Error(`GitHub Content Fetch Failed: ${res.statusText}`);\r\n    }\r\n\r\n    const data = await res.json();\r\n    const content = Buffer.from(data.content, \"base64\").toString(\"utf-8\");\r\n    return { path, content };\r\n}\r\n\r\nfunction constructPrompt(files: { path: string, content: string }[]): string {\r\n    let codeContext = \"\";\r\n    for (const file of files) {\r\n        codeContext += `\\n--- FILE: ${file.path} ---\\n${file.content}\\n`;\r\n    }\r\n\r\n    return `You are a deterministic security scanner. Analyze the following code for ONLY these specific vulnerability types:\r\n\r\nVULNERABILITY CATEGORIES (ONLY report these):\r\n1. SQL Injection (CWE-89) - Unsanitized database queries\r\n2. Cross-Site Scripting (CWE-79) - Unescaped user input in HTML/JS\r\n3. Path Traversal (CWE-22) - File path manipulation\r\n4. Command Injection (CWE-78) - Unsanitized shell commands\r\n5. Hardcoded Secrets (CWE-798) - API keys, passwords in code\r\n6. Insecure Deserialization (CWE-502) - Unsafe object deserialization\r\n7. Authentication Bypass (CWE-287) - Missing or weak auth checks\r\n8. Authorization Issues (CWE-285) - Improper access control\r\n9. Cryptographic Failures (CWE-327) - Weak crypto or insecure random\r\n10. Dependency Vulnerabilities - Known CVEs in packages\r\n\r\nCode Context:\r\n${codeContext}\r\n\r\nANALYSIS RULES:\r\n- ONLY report vulnerabilities with CONCRETE evidence in the code\r\n- Include EXACT line numbers where the issue occurs\r\n- Do NOT report theoretical issues or best practices\r\n- Do NOT report the same issue multiple times\r\n- Be CONSISTENT - same code should produce same findings\r\n- Focus on HIGH and CRITICAL severity issues first\r\n\r\nOutput Format: Valid JSON object with this EXACT structure:\r\n{\r\n  \"findings\": [\r\n    {\r\n      \"id\": \"unique-hash\",\r\n      \"type\": \"SQL Injection | XSS | Path Traversal | Command Injection | Hardcoded Secret | Insecure Deserialization | Auth Bypass | Authorization Issue | Crypto Failure | Dependency Vulnerability\",\r\n      \"name\": \"Brief title (max 50 chars)\",\r\n      \"severity\": \"Critical | High | Medium | Low\",\r\n      \"location\": \"file/path.ts:line_number\",\r\n      \"description\": \"One line explanation (max 80 chars)\",\r\n      \"fix\": \"Specific fix suggestion (max 150 chars)\",\r\n      \"fixTime\": \"30 min | 1 hr | 2 hr | 4 hr\",\r\n      \"detailedAnalysis\": \"Detailed explanation with code snippet\",\r\n      \"codeSnippet\": \"Exact vulnerable code from the file\",\r\n      \"subIssues\": [\r\n        {\r\n          \"id\": \"sub-hash\",\r\n          \"cve\": \"CVE-YYYY-XXXXX\",\r\n          \"severity\": \"Critical | High | Medium | Low\",\r\n          \"package\": \"package-name\",\r\n          \"version\": \"affected version range\",\r\n          \"analysis\": \"Brief CVE description\"\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"summary\": \"X Critical, Y High, Z Medium, W Low vulnerabilities found\"\r\n}\r\n\r\nCRITICAL: \r\n- Return ONLY valid JSON (no markdown, no code blocks, no explanations)\r\n- Include line numbers in location field (format: \"path/file.ts:42\")\r\n- Generate deterministic IDs based on file+line+type\r\n- For dependency issues, include actual CVE numbers from public databases\r\n- Be CONSISTENT across multiple scans of the same code\r\n`;\r\n}\r\n\r\nfunction parseResponse(text: string): any {\r\n    try {\r\n        const cleanText = text.replace(/```json/g, \"\").replace(/```/g, \"\").trim();\r\n        const parsed = JSON.parse(cleanText);\r\n\r\n        // Validate structure\r\n        if (!parsed.findings || !Array.isArray(parsed.findings)) {\r\n            console.warn(\"Invalid findings structure, returning empty array\");\r\n            return { findings: [], summary: \"Failed to parse analysis results.\" };\r\n        }\r\n\r\n        // Add deterministic IDs to findings if not present\r\n        parsed.findings = parsed.findings.map((finding: any, index: number) => {\r\n            if (!finding.id) {\r\n                finding.id = generateDeterministicId(finding);\r\n            }\r\n\r\n            // Ensure required fields exist\r\n            finding.type = finding.type || \"Unknown\";\r\n            finding.severity = finding.severity || \"Low\";\r\n            finding.location = finding.location || \"unknown\";\r\n\r\n            return finding;\r\n        });\r\n\r\n        return parsed;\r\n    } catch (e) {\r\n        console.error(\"Parse error:\", e);\r\n        return { findings: [], summary: \"Failed to parse analysis results.\" };\r\n    }\r\n}\r\n\r\n// Generate deterministic hash-based ID for consistent issue tracking\r\nfunction generateDeterministicId(finding: any): string {\r\n    const crypto = require('crypto');\r\n\r\n    // Extract line number from location if present (e.g., \"file.ts:42\" -> \"42\")\r\n    const lineMatch = finding.location?.match(/:(\\d+)$/);\r\n    const line = lineMatch ? lineMatch[1] : \"0\";\r\n\r\n    // Create deterministic string from key properties\r\n    const idString = `${finding.type}:${finding.location}:${line}:${finding.severity}`;\r\n\r\n    // Generate SHA-256 hash and take first 12 characters\r\n    return crypto\r\n        .createHash('sha256')\r\n        .update(idString)\r\n        .digest('hex')\r\n        .substring(0, 12);\r\n}\r\n"],
  "mappings": "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",
  "names": ["scanner_exports", "__export", "handler", "__toCommonJS", "event", "owner", "repo", "token", "apiKey", "codeFiles", "fetchRepoFiles", "f", "fileContents", "fetchFileContent", "prompt", "constructPrompt", "MAX_RETRIES", "INITIAL_DELAY", "lastError", "response", "attempt", "errorData", "delay", "resolve", "error", "errorText", "aiText", "scanResult", "parseResponse", "path", "res", "errorBody", "data", "files", "item", "content", "codeContext", "file", "text", "cleanText", "parsed", "finding", "index", "generateDeterministicId", "crypto", "lineMatch", "line", "idString"]
}
